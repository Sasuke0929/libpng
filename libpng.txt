libpng.txt - a description on how to use and modify libpng

   libpng 1.0 beta 2 - version 0.8
   For conditions of distribution and use, see copyright notice in png.h
   Copyright (c) 1995 Guy Eric Schalnat, Group 42, Inc.
   August 20, 1995

This file describes how to use and modify the PNG reference library
(known as libpng) for your own use.  There are four sections to this
file: reading, writing, modifying, and configuration notes for various
special platforms.  Other then this file, the file example.c is a good
starting point for using the library, as it is heavily commented and
should include everything most people will need.

Libpng was written as a companion to the PNG specification, as a
way to reduce the amount of time and effort it takes to support
the PNG file format in application programs.  Most users will not
have to modify the library significantly; advanced users may want
to modify it more.  The library was coded for both users.  All
attempts were made to make it as complete as possible, while
keeping the code easy to understand.  Currently, this library
only supports C.  Support for other languages is being considered.

Libpng has been designed to handle multiple sessions at one time,
to be easily modifiable, to be portable to the vast majority of
machines (ANSI, K&R, 16 bit, 32 bit) available, and to be easy to
use.  The ultimate goal of libpng is to promote the acceptance of
the PNG file format in whatever way possible.  While there is still
work to be done (see the todo.txt file), libpng should cover the
majority of the needs of it's users.

Libpng uses zlib for its compression and decompression of PNG files.
The zlib compression utility is a general purpose utility that is
useful for more then PNG files, and can be used without libpng for
whatever use you want.  See the documentation delivered with zlib for
more details.

Those people who do not need to modify libpng should still read at
least part of the PNG specification.  The most important parts are
the data formats and the chunk descriptions.  Those who will be
making changes to libpng should read the whole specification.

The structures:

There are two main structures that are important to libpng, png_struct
and png_info.  The first, png_struct, is an internal structure that
will not, for the most part, be used by the general user except as
the first variable passed to every PNG function call.

The png_info structure is designed to provide information about the
png file.  All of it's fields are intended to be examined or modified
by the user.  See png.h for a good description of the png_info fields.

And while I'm on the topic, make sure you include the PNG header file:

#include <png.h>

Checking PNG files:

Libpng provides a simple check to see if a file is a PNG file.  To
use it, pass in the first 1 to 8 bytes of the file, and it will return
true or false (1 or 0) depending on whether the bytes could be part
of a PNG file.  Of course, the more bytes you pass in, the greater
the accuracy of the prediction.

   fread(header, 1, number, fp);
   is_png = png_check_sig(header, number);

Reading PNG files:

The first thing you need to do while reading a PNG file is to allocate
and initialize png_struct and png_info.  As these are both large, you
may not want to store these on the stack, unless you have stack space
to spare.  Of course, you will want to check if malloc returns NULL.

   png_struct *png_ptr = malloc(sizeof (png_struct));
   if (!png_ptr)
      return;
   png_info *info_ptr = malloc(sizeof (png_info));
   if (!info_ptr)
   {
      free(png_ptr);
      return;
   }

You may also want to do any i/o initialization here, before
you get into libpng, so if it doesn't work, you don't have
much to undo.

   FILE *fp = fopen(file_name, "rb");
   if (!fp)
   {
      free(png_ptr);
      free(info_ptr);
      return;
   }

If you are not using the standard IO functions to do input and
output, and/or not using stderr for your output messages, you will
have the ability to change the functions that libpng uses once
you have allocated the libpng data structures below.

After you have these structures, you will need to set up the
error handling.  When libpng encounters an error, it expects to
longjmp back to your routine.  Therefore, you will need to call
setjmp and pass the jmpbuf field of your png_struct.  If you
read the file from different routines, you will need to update
the jmpbuf field every time you enter a new routine that will
call a png_ function.  See your documentation of setjmp/longjmp
for your compiler for more information on setjmp/longjmp.  See
the discussion on libpng error handling in the Customizing Libpng
section below for more information on how to change the behaviour
of libpng error handling.  If an error occurs, and libpng longjmp's
back to your setjmp, you will want to call png_read_destroy() to
free any memory.

   if (setjmp(png_ptr->jmpbuf))
   {
      png_read_destroy(png_ptr, info_ptr, (png_info *)0);
      /* free pointers before returning, if necessary */
      free(png_ptr);
      free(info_ptr);
      fclose(fp);
      return;
   }

Next, you will need to call png_read_init() and png_info_init().
These functions make sure all the fields are initialized to useful
values, and, in the case of png_read_init(), and allocate any memory
needed for internal uses.  You must call png_info_init() first, as
png_read_init() could do a longjmp, and if the info is not initialized,
the png_read_destroy() could try to png_free() random addresses, which
would be bad.

   png_info_init(info_ptr);
   png_read_init(png_ptr);

Now you need to set up the input code.  The default for libpng is
to use the C function fread().  If you use this, you will need to
pass a valid FILE * in the function png_init_io().  Be sure that
the file is opened in binary mode.  Otherwise, you should see the
section below on Customizing libpng I/O functions.

   png_init_io(png_ptr, fp);

You are now ready to read all the file information up to the actual
image data.  You do this with a call to png_read_info().

   png_read_info(png_ptr, info_ptr);

The png_info structure is now filled in with all the data necessary
to read the file.  Some of the more important parts of the png_info are:
   width - holds the width of the file
   height - holds the height of the file
   bit_depth - holds the bit depth of one of the image channels
   color_type - describes the channels and what they mean
      see the PNG_COLOR_TYPE_ macros for more information
   channels - number of channels of info for the color type
   pixel_depth - bits per pixel
   rowbytes - number of bytes needed to hold a row
   interlace_type - currently 0 for none, 1 for interlaced
   valid - this details which optional chunks were found in the file
      to see if a chunk was present, OR valid with the appropriate
      PNG_INFO_<chunk name> define.
   palette and num_palette - the palette for the file
   gamma - the gamma the file is written at
   sig_bit - the number of significant bits for red, green, blue, grey, alpha
   trans, trans_values, and number_trans - transparency info
   hist - histogram of palette
   text and num_text - text comments in the file.
for more information, see the png_info definition in png.h and the
PNG specification for chunk contents.  Be careful with trusting
rowbytes, as some of the transformations could increase the space
needed to hold a row (expand, rgbx, xrgb, graph_to_rgb, etc.).

A quick word about text and num_text.  PNG stores comments in
keyword/text pairs, one pair per chunk.  While there are
suggested keywords, there is no requirement to restrict the use
to these strings.  There is a requirement to have at least one
character for a keyword.  It is strongly suggested that keywords
be sensible to humans (that's the point), so don't use abbreviations.
Some suggested keywords for tEXT (or zTXt) chunks are:

   Title            Short (one line) title or caption for image
   Author           Name of image's creator
   Copyright        Copyright notice (possibly long)
   Description      Description of image (possibly long)
   Software         Software used to create the image
   Disclaimer       Legal disclaimer (possibly long)
   Warning          Warning of nature of content
   Source           Device used to create the image
   Comment          Miscellaneous comment; conversion from GIF comment
   Created          When the image or source file was created

There is no requirement to have text after the keyword on tEXt chunks.
However, you must have text after the keyword on zTXt chunks, as only
the text gets compressed, and compressing nothing will result in an error.

The maximum length of the keyword is limited to 80 characters.  It is
possible to use the same keyword any number of times.  The text field
is an array of png_text structures, each holding pointer to a keyword
and a pointer to a text string.  Only the text string may be null.
The keyword/text pairs are put into the array in the order that
they are received.  However, some or all of the text chunks may be
after the image, so to make sure you have read all the text chunks,
don't mess with these until after you read the stuff after the image.
This will be mentioned again below in the discussion that goes with
png_read_end().

After you've read the file information, you can set up the library to
handle any special transformations of the image data.  The various
ways to transform the data will be described in the order that they
occur.  This is important, as some of these change the color type
and bit depth of the data, and some others only work on certain
color types and bit depths.  Even though each transformation should
check to see if it has data that it can do somthing with, you should
make sure to only enable a transformation if it will be valid for
the data.  For example, don't swap red and blue on grayscale data.

This transforms bit depths of less than 8 to 8 bits, changes paletted
images to rgb, and adds an alpha channel if there is transparency
information in a tRNS chunk.  This is probably most useful on grayscale
images with bit depths of 2 or 4 and tRNS chunks.

   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
      info_ptr->bit_depth < 8)
      png_set_expand(png_ptr);

   if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY &&
      info_ptr->bit_depth < 8)
      png_set_expand(png_ptr);

   if (info_ptr->valid & PNG_INFO_tRNS)
      png_set_expand(png_ptr);

This handles alpha and transparency by replacing it with a background
value.  If there was a valid one in the file, you can use it if you
want.  However, you can replace it with your own if you want also.  If
there wasn't one in the file, you must supply a color.  If libpng is
doing gamma correction, you will need to tell libpng where the
background came from so it can do the appropriate gamma correction.
If you are modifying the color data with png_set_expand(), you must
indicate whether the background needs to be expanded.  See the
function definition in png.h for more details.

   png_color_16 my_background;

   if (info_ptr->valid & PNG_INFO_bKGD)
      png_set_backgrond(png_ptr, &(info_ptr->background),
         PNG_GAMMA_FILE, 1, 1.0);
   else
      png_set_background(png_ptr, &my_background,
         PNG_GAMMA_SCREEN, 0, 1.0);

This handles gamma transformations of the data.  Pass both the file
gamma and the desired screen gamma.  If the file does not have a
gamma value, you can pass one anyway if you wish.  Note that file
gammas are inverted from screen gammas.  See the discussions on
gamma in the PNG specification for more information.  It is strongly
reccommended that viewers support gamma correction.

   if (info_ptr->valid & PNG_INFO_gAMA)
      png_set_gamma(png_ptr, screen_gamma, info_ptr->gamma);
   else
      png_set_gamma(png_ptr, screen_gamma, 0.45);

PNG can have files with 16 bits per channel.  If you only can handle
8 bits per channel, this will strip the pixels down to 8 bit.

   if (info_ptr->bit_depth == 16)
      png_set_strip_16(png_ptr);

If you need to reduce an rgb file to a paletted file, or if a
paletted file has more entries then will fit on your screen, this
function will do that.  Note that this is a simple match dither, that
merely finds the closest color available.  This should work fairly
well with optimized palettes, and fairly badly with linear color
cubes.  If you pass a palette that is larger then maximum_colors,
the file will reduce the number of colors in the palette so it
will fit into maximum_colors.  If there is an histogram, it will
use it to make intelligent choises when reducing the palette.  If
there is no histogram, it may not do a good job.

   if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
   {
      if (info_ptr->valid & PNG_INFO_PLTE)
         png_set_dither(png_ptr, info_ptr->palette,
            info_ptr->num_palette, max_screen_colors,
               info_ptr->histogram);
      else
      {
         png_color std_color_cube[MAX_SCREEN_COLORS] =
            { ... colors ... };

         png_set_dither(png_ptr, std_color_cube, MAX_SCREEN_COLORS,
            MAX_SCREEN_COLORS, NULL);
      }
   }

PNG files describe monocrome as black is zero and white is one.  If you
want this reversed (black is one and white is zero), call this:

   if (info_ptr->bit_depth == 1 &&
      info_ptr->color_type == PNG_COLOR_GRAY)
      png_set_invert(png_ptr);

PNG files reduce possible bit depths to 1, 2, 4, 8, and 16.  However,
they also provide a way to describe the true bit depth of the image.
Then they require bits to be scaled to full range for the bit depth
used in the file.  If you want to reduce your pixels back down to
the true bit depth, call this:

   if (info_ptr->valid & PNG_INFO_sBIT)
      png_set_shift(png_ptr, &(info_ptr->sig_bit));

PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
they can, resulting in, for example, 8 pixels per byte for 1 bit files.
If you would rather these were expanded to 1 pixel per byte without
changing the values of the pixels, call this:

   if (info_ptr->bit_depth < 8)
      png_set_packing(png_ptr);

PNG files store 3 color pixels in red, green, blue order.  If you would
rather have the pixels as blue, green, red, call this.

   if (info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
      info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      png_set_bgr(png_ptr);

For some uses, you may want a grayscale image to be represented as
rgb.  If you need this, call this:

   if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
      info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      png_set_gray_to_rgb(png_ptr);

PNG files store 16 bit pixels in network byte order (most significant
bit first).  If you would rather store them the other way, (the way
PC's store them, for example), call this:

   if (info_ptr->bit_depth == 16)
      png_set_swap(png_ptr);

PNG files store rgb pixels packed into 3 bytes.  If you would rather
pack them into 4 bytes, call this:

   if (info_ptr->bit_depth == 8 &&
      info_ptr->color_type == PNG_COLOR_TYPE_RGB)
      png_set_filler(png_ptr, filler_byte, PNG_FILLER_BEFORE);

where filler_byte is the number to fill with, and the location is
either PNG_FILLER_BEFORE or PNG_FILLER_AFTER, depending upon whether
you want the filler before the rgb or after.

Finally, if you need the interlacing as discussed below, call
this here:

   if (info_ptr->interlace_type)
      number_passes = png_set_interlace_handling(png_ptr);

After setting the transformations, you can update your palette by
calling png_start_read_image().  This function is provided for those
who need an updated palette before they read the image data.  If you
don't call this function, the library will automatically call it
before it reads the first row.

   png_start_read_image(png_ptr);

If you want, libpng will update your png_info structure to reflect
any transformations you've requested with this call.  This is most
useful to update the info structures rowbytes field, so you can
use it to allocate your image memory.  This function calls
png_start_read_image(), so you don't have to call both of them.

   png_read_update_info(png_ptr, info_ptr);

After you call png_read_update_info(), you can allocate any
memory you need to hold the image.  As the actual allocation
varies among applications, no example will be given.  If you
are allocating one large chunk, you may find it useful to
build an array of pointers to each row, as it will be needed
for some of the functions below.

After you've allocated memory, you can read the image data.
The simplest way to do this is in one function call.  If you are
allocating enough memory to hold the whole image, you can just
call png_read_image() and libpng will read in all the image data
and put it in the memory area supplied.  You will need to pass in
an array of pointers to each row.

This function automatically handles interlacing, so you don't need
to call png_set_interlace_handling() or call this function multiple
times, or any of that other stuff necessary with png_read_rows().

   png_read_image(png_ptr, row_pointers);

where row_pointers is:

   void *row_pointers[height];

You can point to void or char or whatever you use for pixels.

If you don't want to read the whole image in at once, you can
use png_read_rows() instead.  If there is no interlacing (check
info_ptr->interlace_type), this is simple:

   png_read_rows(png_ptr, row_pointers, NULL, number_of_rows);

row_pointers is the same as in the png_read_image() call.

If you are just calling one row at a time, you can do this for
row_pointers:

   char *row_pointers = row;

   png_read_rows(png_ptr, &row_pointers, NULL, 1);

When the file is interlaced (info_ptr->interlace_type == 1), things
get a good deal harder.  PNG files have a complicated interlace scheme
that breaks down an image into seven smaller images of varying size.
Libpng will fill out those images if you want, or it will give them
to you "as is".  If you want to fill them out, there is two ways
to do that.  The one mentioned in the PNG specification is to expand
each pixel to cover those pixels that have not been read yet.  This
results in a blocky image for the first pass, which gradually smooths
out as more pixels are read.  The other method is the "sparkle" method,
where pixels are draw only in their final locations, with the rest of
the image remaining whatever colors they were initialized to before
the start of the read.  The first method usually looks better, but
tends to be slower, as there are more pixels to put in the rows.  Some
examples to help clear this up:

If you don't want libpng to handle the interlacing details, just
call png_read_rows() the correct number of times to read in all
seven images.  See the PNG specification for more details on the
interlacing scheme.

If you want libpng to expand the images, call this above:

   if (info_ptr->interlace_type)
      number_passes = png_set_interlace_handling(png_ptr);

This will return the number of passes needed.  Currently, this
is seven, but may change if another interlace type is added.
This function can be called even if the file is not interlaced,
when it will return one.

If you are not going to display the image after each pass, but are
going to wait until the entire image is read in, use the sparkle
effect.  This effect is faster and the end result of either method
is exactly the same.  If you are planning on displaying the image
after each pass, the rectangle effect is generally considered the
better looking one.

If you only want the "sparkle" effect, just call png_read_rows() as
normal, with the third parameter NULL.  Make sure you make pass over
the image number_passes times, and you don't change the data in the
rows between calls.  You can change the locations of the data, just
not the data.  Each pass only writes the pixels appropriate for that
pass, and assumes the data from previous passes is still valid.

   png_read_rows(png_ptr, row_pointers, NULL, number_of_rows);

If you only want the first effect (the rectangles), do the same as
before except pass the row buffer in the third parameter, and leave
the second parameter NULL.

   png_read_rows(png_ptr, NULL, row_pointers, number_of_rows);

After you are finished reading the image, you can finish reading
the file.  If you are interested in comments or time, you should
pass the png_info pointer from the png_read_info() call.  If you
are not interested, you can pass NULL.

   png_read_end(png_ptr, info_ptr);

When you are done, you can free all memory used by libpng like this:

   png_read_destroy(png_ptr, info_ptr, (png_info *)0);

After that, you can discard the structures, or reuse them another
read or write.  For a more compact example of reading a PNG image,
see the file example.c.


Writing PNG files:

Much of this is very similar to reading.  However, everything of
importance is repeated here, so you don't have to constantly look
back up in the Reading PNG files section to understand writing.

The first thing you need to do while writing a PNG file is to allocate
and initialize png_struct and png_info.  As these are both large, you
may not want to store these on the stack, unless you have stack space
to spare.

   png_struct *png_ptr = malloc(sizeof (png_struct));
   if (!png_ptr)
      return;
   png_info *info_ptr = malloc(sizeof (png_info));
   if (!info_ptr)
   {
      free(png_ptr);
      return;
   }

You may also want to do any i/o initialization here, before
you get into libpng, so if it doesn't work, you don't have
much to undo.

   FILE *fp = fopen(file_name, "wb");
   if (!fp)
   {
      free(png_ptr);
      free(info_ptr);
      return;
   }

After you have these structures, you will need to set up the
error handling.  When libpng encounters an error, it expects to
longjmp back to your routine.  Therefore, you will need to call
setjmp and pass the jmpbuf field of your png_struct.  If you
write the file from different routines, you will need to update
the jmpbuf field every time you enter a new routine that will
call a png_ function.  See your documentation of setjmp/longjmp
for your compiler for more information on setjmp/longjmp.  If you
don't want to use stderr for error output, or you want to use a
method other than setjmp()/longjmp() to handle errors, see the
Customizing Libpng section below for more information on libpng
error handling.

   if (setjmp(png_ptr->jmpbuf))
   {
      png_write_destroy(png_ptr);
      /* free pointers before returning.  Make sure you clean up
         anything else you've done. */
      free(png_ptr);
      free(info_ptr);
      fclose(fp);
      return;
   }

Next, you will need to call png_write_init() and png_info_init().
These functions make sure all the fields are initialized to useful
values, and, in the case of png_write_init(), allocate any memory
needed for internal uses.  Do png_info_init() first, so if
png_write_init() longjmps, you know info_ptr is valid, so you
don't free random memory pointers, which would be bad.

   png_info_init(info_ptr);
   png_write_init(png_ptr);

Now you need to set up the input code.  The default for libpng is
to use the C function fwrite().  If you use this, you will need to
pass a valid FILE * in the function png_init_io().  Be sure that
the file is opened in binary mode.  If you wish to handle writing
data in another way, see the discussion on PNG I/O handling in the
Customizing Libpng section below.

   png_init_io(png_ptr, fp);

You now have the option of modifying how the compression library
will run.  The following functions are mainly for testing, but
may be useful in certain special cases, like if you need to
write PNG files extremely fast and are willing to give up some
compression, or if you want to get the maximum possible compression
at the expense of slower writing.  If you have no special needs
in this area, let the library do what it wants, as it has been
carefully tuned to deliver the best speed/compression ratio.
See the compression library for more details.

   /* turn on or off filtering (1 or 0) */
   png_set_filtering(png_struct *png_ptr, 1);

   /* compression level (0 - none, 6 - default, 9 - maximum) */
   png_set_compression_level(png_ptr, Z_DEFAULT_COMPRESSION);
   png_set_compression_mem_level(png_ptr, 8);
   png_set_compression_strategy(png_ptr, Z_DEFAULT_STRATEGY);
   png_set_compression_window_bits(png_ptr, 15);
   png_set_compression_method(png_ptr, 8);

It is possible to have libpng flush any pending output, either manually,
or automatically after a certain number of lines have been written.  To
flush the output stream a single time call:

   png_write_flush(png_ptr);

and to have libpng flush the output stream after a certain number of
scanlines have been written, call:

   png_set_flush(png_ptr, nrows);

Note that the distance between rows is from the last time png_write_flush
was called, or the first row of the image if it has never been called.
So if you write 50 lines, and then png_set_flush 25, it will flush the
output on the next scanline, and on line 75, unless png_write_flush is
called earlier.  If nrows is too small (less than about 10 lines) the
image compression may decrease dramatically (although this may be
acceptable for real-time applications).  Infrequent flushing will only
degrade the compression performance by a few percent over images that
do not use flushing.
   
You now need to fill in the png_info structure with all the data
you wish to write before the actual image.  Note that the only thing
you are allowed to write after the image is the text chunks and the
time chunk.  See png_write_end() for more information on that.  If you
wish to write them before the image, fill them in now.  If you want to
wait until after the data, don't fill them until png_write_end().  For
all the fields in png_info, see png.h.  For explinations of what the
fields contain, see the PNG specification.  Some of the more important
parts of the png_info are:
   width - holds the width of the file
   height - holds the height of the file
   bit_depth - holds the bit depth of one of the image channels
   color_type - describes the channels and what they mean
      see the PNG_COLOR_TYPE_ defines for more information
   interlace_type - currently 0 for none, 1 for interlaced
   valid - this describes which optional chunks to write to the
      file.  Note that if you are writing a PNG_COLOR_TYPE_PALETTE
      file, the PLTE chunk is not optional, but must still be marked
      for writing.  To mark chunks for writing, OR valid with the
      appropriate PNG_INFO_<chunk name> define.
   palette and num_palette - the palette for the file
   gamma - the gamma the file is written at
   sig_bit - the number of significant bits for red, green, blue, grey, alpha
   trans, trans_values, and number_trans - transparency info
   hist - histogram of palette
   text and num_text - text comments in the file.

A quick word about text and num_text.  text is an array of png_text
structures.  num_text is the number of valid structures in the array.
If you want, you can use max_text to hold the size of the array, but
libpng ignores it for writing (it does use it for reading).  Each
png_text structure holds a keyword-text value, and a compression type.
The compression types have the same valid numbers as the compression
types of the image data.  Currently, the only valid number is zero.
However, you can store text either compressed or uncompressed, unlike
images which always have to be compressed.  So if you don't want the
text compressed, set the compression type to -1.  Until text gets
arount 1000 bytes, it is not worth compressing it.

The keyword-text pairs work like this.  Keywords should be short
simple descriptions of what the comment is about.  Some typical
keywords are found in the PNG specification, as is some recomendations
on keywords.  You can repeat keywords in a file.  You can even write
some text before the image and some after.  For example, you may want
to put a description of the image before the image, but leave the
disclaimer until after, so viewers working over modem connections
don't have to wait for the disclaimer to go over the modem before
they start seeing the image.  Finally, keywords should be full
words, not abbreviations.  Keywords can not contain NUL characters,
and should not contain control characters.  Text in general should
not contain control characters.  The keyword must be present, but
you can leave off the text string on non-compressed pairs.
Compressed pairs must have a text string, as only the text string
is compressed anyway, so the compression would be meaningless.

PNG supports MODIFICATION time via the png_time structure.  Two
conversion routines are proved, png_convert_from_time_t() for
time_t and png_convert_from_struct_tm() for struct tm.  The
time_t routine uses gmtime().  You don't have to use either of
these, but if you wish to fill in the png_time structure directly,
you should provide the time in universal time (GMT) if possible
instead of your local time.  Note that the year number is the full
year number (ie 1995 rather than 95).

Since the CREATION time of an image is somewhat ambiguous, it is not
sensible to store an exact time like the tIME chunk above (ie when was
a scanned photo of neanderthal art created?).  However, a text chunk
with a "Created" keyword can hold this information, in a form which is
useful (ie "Painted circa 40000 BC, photographed 1971, scanned 1996").

You are now ready to write all the file information up to the actual
image data.  You do this with a call to png_write_info().

   png_write_info(png_ptr, info_ptr);

After you've read the file information, you can set up the library to
handle any special transformations of the image data.  The various
ways to transform the data will be described in the order that they
occur.  This is important, as some of these change the color type
and bit depth of the data, and some others only work on certain
color types and bit depths.  Even though each transformation should
check to see if it has data that it can do somthing with, you should
make sure to only enable a transformation if it will be valid for
the data.  For example, don't swap red and blue on grayscale data.

PNG files store rgb pixels packed into 3 bytes.  If you would rather
supply the pixels as 4 bytes per pixel, call this:

   png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);

where the 0 is not used for writing, and the location is either
PNG_FILLER_BEFORE or PNG_FILLER_AFTER, depending upon whether you
want the filler before the rgb or after.

PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
they can, resulting in, for example, 8 pixels per byte for 1 bit files.
If you would rather supply the data 1 pixel per byte, but with the
values limited to the correct number of bits, call this:

   png_set_packing(png_ptr);

PNG files reduce possible bit depths to 1, 2, 4, 8, and 16.  If your
data is of another bit depth, but is packed into the bytes correctly,
this will scale the values to appear to be the correct bit depth.
Make sure you write a sBIT chunk when you do this, so others, if
they want, can reduce the values down to their true depth.

   /* do this before png_write_info() */
   info_ptr->valid |= PNG_INFO_sBIT;

   /* note that you can cheat and set all the values of
      sig_bit to true_bit_depth if you want */
   if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
   {
      info_ptr->sig_bit.red = true_bit_depth;
      info_ptr->sig_bit.green = true_bit_depth;
      info_ptr->sig_bit.blue = true_bit_depth;
   }
   else
   {
      info_ptr->sig_bit.gray = true_bit_depth;
   }

   if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
   {
      info_ptr->sig_bit.alpha = true_bit_depth;
   }

   png_set_shift(png_ptr, &(info_ptr->sig_bit));

PNG files store 16 bit pixels in network byte order (most significant
bit first).  If you would rather supply them the other way, (the way
PC's store them, for example), call this:

   png_set_swap(png_ptr);

PNG files store 3 color pixels in red, green, blue order.  If you would
rather supply the pixels as blue, green, red, call this.

   png_set_bgr(png_ptr);

PNG files describe moncrome as black is zero and white is one.  If you
would rather supply the pixels with this reversed (black is one and
white is zero), call this:

   png_set_invert(png_ptr);

That's it for the transformations.  Now you can write the image data.
The simplest way to do this is in one function call.  If have the
whole image in memory, you can just call png_write_image() and libpng
will write the image.  You will need to pass in an array of pointers to
each row.  This function automatically handles interlacing, so you don't
need to call png_set_interlace_handling() or call this function multiple
times, or any of that other stuff necessary with png_write_rows().

   png_write_image(png_ptr, row_pointers);

where row_pointers is:

   void *row_pointers[height];

You can point to void or char or whatever you use for pixels.

If you can't want to write the whole image at once, you can
use png_write_rows() instead.  If the file is not interlaced,
this is simple:

   png_write_rows(png_ptr, row_pointers, number_of_rows);

row_pointers is the same as in the png_write_image() call.

If you are just calling one row at a time, you can do this for
row_pointers:

   char *row_pointers = row;

   png_write_rows(png_ptr, &row_pointers, 1);

When the file is interlaced, things can get a good deal harder.
PNG files have a complicated interlace scheme that breaks down an
image into seven smaller images of varying size.  Libpng will
build these images if you want, or you can do them yourself.  If
you want to build them yourself, see the PNG specification for
details of which pixels to write when.

If you don't want libpng to handle the interlacing details, just
call png_write_rows() the correct number of times to write all
seven sub-images.

If you want libpng to build the sub-images, call this:

   number_passes = png_set_interlace_handling(png_ptr);

This will return the number of passes needed.  Currently, this
is seven, but may change if another interlace type is added.

Then write the image number_passes times.

   png_write_rows(png_ptr, row_pointers, number_of_rows);

As some of these rows are not used, and thus return immediately,
you may want to read about interlacing in the PNG specification,
and only update the rows that are actually used.

After you are finished writing the image, you should finish writing
the file.  If you are interested in writing comments or time, you should
pass the an appropriately filled png_info pointer.  If you
are not interested, you can pass NULL.  Be careful that you don't
write the same text or time chunks here as you did in png_write_info().

   png_write_end(png_ptr, info_ptr);

When you are done, you can free all memory used by libpng like this:

   png_write_destroy(png_ptr);

Any data you allocated for png_info, you must free yourself.

After that, you can discard the structures, or reuse them another
read or write.  For a more compact example of writing a PNG image,
see the file example.c.


Customizing libpng:

There are two issues here.  The first is changing how libpng does
standard things like memory allocation, input/output, and error handling.
The second deals with more complicated things like adding new chunks,
adding new transformations, and generally changing how libpng works.

All of the memory allocation in libpng is done in pngmem.c.  Memory
allocation is done through the functions png_large_malloc(), png_malloc(),
png_realloc(), png_large_free(), and png_free().  These currently just
call the standard C functions.  The large functions must handle at least
64K, but they don't have to handle more then that.  If your pointers can't
access more then 64K at a time, you will want to set MAXSEG_64K in zlib.h.

Since it is unlikely that the method of handling memory allocation on a
platform will change between applications, these functions must be modified
or replaced to change their behaviour.  If you only need to add new tests or
flags to have the compiler choose the correct function calls, please forward
these changes to the libpng author, so they can be added into the library
for the benefit of others.

All of the input/output, and error handling in libpng go through the
routines in pngio.c by default.  The file has plenty of comments describing
each function and how it expects to work.  It is possible to supply different
I/O and error handling methods at run time with the png_set_msg_fn(),
png_set_read_fn(), and png_set_write_fn() calls.

Input/Output in libpng is done throught png_read_data() and png_write_data(),
which currently just call fread() and fwrite().  The error and warning
functions png_error() and png_warning() use stderr to output any messages,
and png_error() uses longjmp to return from an error.  These default
functions are set by via png_init_io().

If you wish to change some or all of these functions, it is possible to
do so at runtime, and without modifying the libpng library code.  The
application must supply replacement functions which have the same arguments
and are functionally equivalent to the default functions.  If you are
replacing both the I/O and message functions, the call to png_init_io()
is not needed.

Error handling in libpng is done through png_error() and png_warning() by
default.  Errors handled through png_error() are fatal, meaning that
png_error() should never return to it's caller.  Currently, this is handled
via setjmp() and longjmp(), but you could change this to do things like
exit() if you should wish.  Similarly, both png_error() and png_warning()
print a message on stderr, but that can also be changed.  The motivation
behind using setjmp() and longjmp() is the C++ throw and catch exception
handling methods.  This makes the code much easier to write, as there
is no need to check every return code of every function call.  However,
there are some uncertainties about the status of local variables after
a longjmp, so the user may want to be careful about doing anything after
setjmp returns non zero besides returning itself.  Consult your compiler
documentation for more details.

The replacement message functions should have parameters as follows:

   void user_error_fn(png_struct png_ptr, char *error_msg);
   void user_warning_fn(png_struct png_ptr, char *warning_msg);

These functions can be attached to a PNG stream with a call

   png_set_msg_fn(png_ptr, msg_ptr, user_error_fn, user_warning_fn);

If NULL is supplied for user_error_fn, then the error function will not
print any error messages, and will return via longjmp(png_ptr->jmpbuf,1) to
the last location setjmp(png_ptr->jmpbuf) was previously called.  If NULL is
supplied for user_warning_fn then no warning messages will be printed.

In order to make it possible to have multiple PNG files open at the same
time, the replacement message functions should not modify any global
variables.  In order to have any message information available to the
libpng streams, there is a pointer available to for a user variable or
structure.  If more than one variable or structure of needs to be kept
with each stream, then you must create a structure which holds all the
relevant data.  The pointer to this data is set in the initial png_set_msg_fn
call, and can be accessed with:

   msg_ptr = (user_msg_type *)png_get_msg_ptr(png_ptr);

The replacement I/O functions should have prototypes as follows:

   void user_read_data(png_struct *png_ptr,png_bytef *data,png_uint_32 length);
   void user_write_data(png_struct *png_ptr,png_bytef *data,png_uint_32 length);

where the routine will read or write "length" bytes into or out of "data".
If the routines are unable to read or write the correct number of bytes, they
should call (*(png_ptr->error_fn))(png_ptr, "Error message"); to abort.

   void user_output_flush(png_struct *png_ptr);

will flush any data from the buffer used by the output device.  Note that
the flush function is purely to output any data being stored by the write
function, and has no control over any data buffered inside the compressor.

These functions can be attached to a PNG stream by calling one of

   png_set_read_fn(png_ptr, io_ptr, user_read_data);
   png_set_write_fn(png_ptr, io_ptr, user_write_data, user_output_flush);

You should only call one of these two functions for a single PNG stream.
It is a fatal error to read from a write stream, and vice-versa.  If the
output method you are using does not buffer any data, or you have chosen
not to compile libpng with PNG_WRITE_FLUSH_SUPPORTED, NULL may be supplied
instead of a function name for user_output_flush, and an empty function will
be used.  Note that even if the output method being used does not buffer
output, during compression data is buffered by the compressor.  If an
application wants to guarantee that all pending output data has been written,
it should call png_write_flush, which will flush the compression buffers,
and in turn call the user_output_flush function.

As with the message functions, the replacement I/O functions should not
modify any global variables.  Therse is a separate pointer available to for
an I/O variable or structure.  If more than one variable or structure of
needs to be kept with each stream, then you must create a structure which
holds all the relevant data.  The pointer to this data is set in the initial
set_xxx_fn call, and can be accessed with:

   io_ptr = (user_io_type *)png_get_io_ptr(png_ptr);

If you need to read or write custom chunks, you will need to get deeper
into the libpng code.  First, read the PNG specification, and have
a first level of understanding of how it works.  Pay particular
attention to the sections that describe chunk names, and look
at how other chunks were designed, so you can do things similar.
Second, check out the sections of libpng that read and write chunks.
Try to find a chunk that is similar to yours, and copy off of it.
More details can be found in the comments inside the code.  If you are
truly ambitious, you can modify the libpng code to handle unknown chunks
in a general way and send the code to the libpng author.

If you wish to write your own transformation for the data, look
through the part of the code that does the transformations, and check
out some of the more simple ones to get an idea of how they work.  Try
to find a similar transformation to the one you want to add, and copy
off of it.  More details can be found in the comments inside the code
itself.

Configuring for 16 bit platforms:

You will probably need to change the png_large_malloc() and
png_large_free() routines in pngmem.c, as these are required
to allocate 64K.  Also, you will want to look into zconf.h to tell
zlib (and thus libpng) that it cannot allocate more then 64K at a
time.  Even if you can, the memory won't be accessable.  So limit zlib
and libpng to 64K by defining MAXSEG_64K.

Configuring for gui/windowing platforms:

You will need to supply new message display functions for png_error() and
png_warning() (through png_set_message_fn() to display a message in a window
instead of fprinting it to stderr.  You may want to write a single function
to do this and call it something like png_message() (although the error
function should still call longjmp or otherwise handle the error without
returning).

Configuring for compiler xxx:

All includes for libpng are in png.h.  If you need to add/change/delete
an include, this is the place to do it.  The includes that are not
needed outside libpng are protected by the PNG_INTERNAL definition,
which is only defined for those routines inside libpng itself.  The
files in libpng proper only include png.h.

Removing unwanted object code:

There are a bunch of #define's in pngconf.h that control what parts of
libpng are compiled.  All the defines end in _SUPPORT.  If you are
never going to use an ability, you can change the #define to #undef and
save yourself code and data space.  All the reading and writing
specific code are in seperate files, so the linker should only grab
the files it needs.  However, if you want to make sure, or if you
are building a stand alone library, all the reading files start with
pngr and all the writing files start with pngw.  The files that
don't match either (like png.c, pngtrans.c, etc.) are used for
both reading and writing, and always need to be included.
